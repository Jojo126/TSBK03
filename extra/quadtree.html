<html>
	<head>
		<title>Quadtree</title>
	</head>
	<body>
        <script src="../js/three.js"></script>
		<script>
            let scene = new THREE.Scene();
			let camera = new THREE.PerspectiveCamera( 75, window.innerWidth/window.innerHeight, 0.1, 1000 );

			let renderer = new THREE.WebGLRenderer();
			renderer.setSize( window.innerWidth, window.innerHeight );
			document.body.appendChild( renderer.domElement );

            const CLOTHWIDTH = 15;
            const CLOTHHEIGHT = 15;
            const WIDTHSEGMENTS = 41;
            const HEIGHTSEGMENTS = 41;
            let planeGeometry = new THREE.PlaneBufferGeometry( CLOTHWIDTH, CLOTHHEIGHT, WIDTHSEGMENTS, HEIGHTSEGMENTS );
            //Information about vertices positions (only to be read)
            let planeVertices = planeGeometry.getAttribute('position');
            //console.log(planeVertices);
            
            
            /******************   Create hierarchy for vertices   ******************/
            //create array of indices to use with getX, getY, getZ later
            let counter = 0;
            let indexArray = [];
            for (let i = 1; i <= planeVertices.count; i++) {
                indexArray.push(counter);
                counter++;
                //console.log(array);
            }
            //console.log(indexArray);
            
            
            //recursively divide array into subgroups (only done once!)
            let rowPivot, columnPivot, i;                        
            let divideGroup = (rows, columns, subArray) => {
                rowPivot = Math.ceil(rows/2)*columns; //8
                columnPivot = Math.ceil(columns/2); //2
                
                //console.log("rows: " + rows);
                //console.log("cols: " + columns);
                //console.log("subArray: " + subArray);
                
                //base-case
                if (subArray.length <= 1) {
                    return { vertices: subArray };
                } 
                else {
                    let firstGroup = [];
                    let secondGroup = [];
                    let thirdGroup = [];
                    let fourthGroup = [];
                
                    for(i = 0; i < subArray.length; i++) {
                        //create for new subgroups
                        //send correct array of vertices into groups
                        //första 
                        if(i < rowPivot && i % columns <= columnPivot-1) {
                            firstGroup.push(subArray[i]);
                            //console.log("första för: " + i);
                        }
                        //andra
                        else if(i < rowPivot && i % columns > columnPivot-1) {
                            secondGroup.push(subArray[i]);
                            //console.log("andra för: " + i);
                        }
                        else if(i >= rowPivot && i % columns <= columnPivot-1) {
                            thirdGroup.push(subArray[i]);
                            //console.log("tredje för: " + i);
                        } 
                        else {
                        fourthGroup.push(subArray[i]);
                        //console.log("fjärde för: " + i);
                        }
                    }
                    //console.log("firstgroup: " + firstGroup);
                    //console.log("secondGroup: " + secondGroup);
                    //console.log("thirdGroup: " + thirdGroup);
                    //console.log("fourthGroup: " + fourthGroup);
                    
                    let firstObject = divideGroup(Math.ceil(rows/2), Math.ceil(columns/2), firstGroup);
                    let secondObject = divideGroup(Math.ceil(rows/2), columns - Math.ceil(columns/2), secondGroup);
                    let thirdObject = divideGroup(rows - Math.ceil(rows/2), Math.ceil(columns/2), thirdGroup);
                    let fourthObject = divideGroup(rows - Math.ceil(rows/2), columns - Math.ceil(columns/2), fourthGroup);
                
                    return {
                        vertices: subArray,
                        firstQuadrant: firstObject,
                        secondQuadrant: secondObject,
                        thirdQuadrant: thirdObject,
                        fourthQuadrant: fourthObject
                    };
                }
            }
            
            let root = divideGroup(WIDTHSEGMENTS+1, HEIGHTSEGMENTS+1, indexArray);
            //console.log(root);
            
            /**************************/
            
            
            
            /************************** compute bounding spheres *****************************/
            // Algorithm from:
            // https://www.researchgate.net/publication/242453691_An_Efficient_Bounding_Sphere
            
            let computeBoundingSphere = (indexList, vertexRadius) => {
                
                // loopa genom alla vertexar i grupp
                // hitta tre par vertexar för varje dimension
                let minX=0, maxX=0, minY=0, maxY=0, minZ=0, maxZ=0, averagePos = new THREE.Vector3(0,0,0);
                for (let i = 0; i < indexList.length; i++) {
                    
                    // translate from listed indices to planes indices
                    let planeIndex = indexList[i];
                    
                    if(planeVertices.getX(minX) > planeVertices.getX(planeIndex))
                        minX = planeIndex;
                    if(planeVertices.getX(maxX) < planeVertices.getX(planeIndex))
                        maxX = planeIndex;
                    if(planeVertices.getY(minY) > planeVertices.getY(planeIndex))
                        minY = planeIndex;
                    if(planeVertices.getY(maxY) < planeVertices.getY(planeIndex))
                        maxY = planeIndex;
                    if(planeVertices.getZ(minZ) > planeVertices.getZ(planeIndex))
                        minZ = planeIndex;
                    if(planeVertices.getZ(maxZ) < planeVertices.getZ(planeIndex))
                        maxZ = planeIndex;
                
                    averagePos.add(new THREE.Vector3(planeVertices.getX(planeIndex),planeVertices.getY(planeIndex),planeVertices.getZ(planeIndex)));
                    //console.log(averagePos);
                }
                // Three coordinate pairs for each axis with longest distance
                //console.log("X-coords: " + planeVertices.getX(minX) + ", " + planeVertices.getX(maxX));
                //console.log("Y-coords: " + planeVertices.getY(minY) + ", " + planeVertices.getY(maxY));
                //console.log("Z-coords: " + planeVertices.getZ(minZ) + ", " + planeVertices.getZ(maxZ));
            
                let xDist = planeVertices.getX(maxX) - planeVertices.getX(minX);
                let yDist = planeVertices.getY(maxY) - planeVertices.getY(minY);
                let zDist = planeVertices.getZ(maxZ) - planeVertices.getZ(minZ);
                let biggestDist = Math.max(xDist, yDist, zDist);
                //console.log("biggets distance in axis" + biggestDist);
                let radius = biggestDist/2;
                //averagePos = bounding spheres center
                averagePos.divideScalar(indexArray.length);
                //console.log(averagePos);
            
                // loop through again to find non-included vertices
                for (let i = 0; i < indexList.length; i++) {
                    // translate listed indices to planes indices
                    let planeIndex = indexList[i];
                    
                    let distPointToSphereSquared = (planeVertices.getX(planeIndex)-averagePos.x)*(planeVertices.getX(planeIndex)-averagePos.x) + 
                                                    (planeVertices.getY(planeIndex)-averagePos.y)*(planeVertices.getY(planeIndex)-averagePos.y) + 
                                                    (planeVertices.getZ(planeIndex)-averagePos.z)*(planeVertices.getZ(planeIndex)-averagePos.z);
                
                    if(distPointToSphereSquared > radius*radius)
                    {
                        let distPointToSphere = Math.sqrt(distPointToSphereSquared);
                        let avrgPosX = (radius*averagePos.x +(distPointToSphere-radius)*planeVertices.getX(planeIndex))/distPointToSphere,
                        avrgPosY = (radius*averagePos.y +(distPointToSphere-radius)*planeVertices.getY(planeIndex))/distPointToSphere,
                        avrgPosZ = (radius*averagePos.z +(distPointToSphere-radius)*planeVertices.getZ(planeIndex))/distPointToSphere;
                    
                        radius = (radius + distPointToSphere)/2;
                        averagePos.set(avrgPosX, avrgPosY, avrgPosZ);
                        console.log("Updated radius to: " + radius);
                        console.log("Updated sphere center to: (" + avrgPosX + ", " + avrgPosY + ", " + avrgPosZ + ")");
                    }
                }
                //add radius of vertices own bounding spheres (bounding sphere should include all sub-bounding spheres)
                radius += vertexRadius;
                console.log('final radii: ' + radius);
                
                /*
                // Checks if any vertex is not covered by bounding sphere after creation and adjustments
                for (let j = 0; j < indexArray.length; j++) {
                    if((planeVertices.getX(j)-averagePos.x)*(planeVertices.getX(j)-averagePos.x) + 
                        (planeVertices.getY(j)-averagePos.y)*(planeVertices.getY(j)-averagePos.y) + 
                        (planeVertices.getZ(j)-averagePos.z)*(planeVertices.getZ(j)-averagePos.z) > radius*radius)
                        console.log("found vertex " + j + " outside of bounding sphere!");                    
                }*/
            }
            
            computeBoundingSphere([0,1,2,3,4,5,6,7,8,9,41,1000,1600], 3);
            //computeBoundingSphere(indexArray);
            
            /*******************************************************/
            
            
            let material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );
			let cube = new THREE.Mesh( planeGeometry, material );
			scene.add( cube );

			camera.position.z = 15;

			let animate = function () {
				requestAnimationFrame( animate );
                
                cube.rotation.x += 0.01;
                cube.rotation.y += 0.01;

				renderer.render( scene, camera );
			};

			animate();
            
            //get vertex in group/leaf
            //console.log(root.firstQuadrant.thirdQuadrant.vertices[0]);            
            
        </script>
    </body>
</html>