<html>
	<head>
		<title>Quadtree</title>
	</head>
	<body>
        <script src="../js/three.js"></script>
		<script>
            let scene = new THREE.Scene();
			let camera = new THREE.PerspectiveCamera( 75, window.innerWidth/window.innerHeight, 0.1, 1000 );

			let renderer = new THREE.WebGLRenderer();
			renderer.setSize( window.innerWidth, window.innerHeight );
			document.body.appendChild( renderer.domElement );

            const CLOTHWIDTH = 15;
            const CLOTHHEIGHT = 15;
            const WIDTHSEGMENTS = 41;
            const HEIGHTSEGMENTS = 41;
            let planeGeometry = new THREE.PlaneBufferGeometry( CLOTHWIDTH, CLOTHHEIGHT, WIDTHSEGMENTS, HEIGHTSEGMENTS );
            //Information about vertices positions (only to be read)
            let planeVertices = planeGeometry.getAttribute('position');
            //console.log(planeVertices);
            
            
            /******************   Create hierarchy for vertices   ******************/
            //create array of indices to use with getX, getY, getZ later
            let counter = 0;
            let indexArray = [];
            for (let i = 1; i <= planeVertices.count; i++) {
                indexArray.push(counter);
                counter++;
                //console.log(array);
            }
            //console.log(indexArray);
            
            
            //recusrively divide array into subgroups (only done once!)
            let rowPivot, columnPivot, i;                        
            let divideGroup = (rows, columns, subArray) => {
                rowPivot = Math.ceil(rows/2)*columns; //8
                columnPivot = Math.ceil(columns/2); //2
                
                //console.log("rows: " + rows);
                //console.log("cols: " + columns);
                //console.log("subArray: " + subArray);
                
                //base-case
                if (subArray.length <= 1) {
                    return { vertices: subArray };
                } 
                else {
                    let firstGroup = [];
                    let secondGroup = [];
                    let thirdGroup = [];
                    let fourthGroup = [];
                
                    for(i = 0; i < subArray.length; i++) {
                        //create for new subgroups
                        //send correct array of vertices into groups
                        //första 
                        if(i < rowPivot && i % columns <= columnPivot-1) {
                            firstGroup.push(subArray[i]);
                            //console.log("första för: " + i);
                        }
                        //andra
                        else if(i < rowPivot && i % columns > columnPivot-1) {
                            secondGroup.push(subArray[i]);
                            //console.log("andra för: " + i);
                        }
                        else if(i >= rowPivot && i % columns <= columnPivot-1) {
                            thirdGroup.push(subArray[i]);
                            //console.log("tredje för: " + i);
                        } 
                        else {
                        fourthGroup.push(subArray[i]);
                        //console.log("fjärde för: " + i);
                        }
                    }
                    //console.log("firstgroup: " + firstGroup);
                    //console.log("secondGroup: " + secondGroup);
                    //console.log("thirdGroup: " + thirdGroup);
                    //console.log("fourthGroup: " + fourthGroup);
                    
                    let firstObject = divideGroup(Math.ceil(rows/2), Math.ceil(columns/2), firstGroup);
                    let secondObject = divideGroup(Math.ceil(rows/2), columns - Math.ceil(columns/2), secondGroup);
                    let thirdObject = divideGroup(rows - Math.ceil(rows/2), Math.ceil(columns/2), thirdGroup);
                    let fourthObject = divideGroup(rows - Math.ceil(rows/2), columns - Math.ceil(columns/2), fourthGroup);
                
                    return {
                        vertices: subArray,
                        firstQuadrant: firstObject,
                        secondQuadrant: secondObject,
                        thirdQuadrant: thirdObject,
                        fourthQuadrant: fourthObject
                    };
                }
            }
            
            let root = divideGroup(WIDTHSEGMENTS+1, HEIGHTSEGMENTS+1, indexArray);
            //console.log(root);
            
            /**************************/
            
            
            
            /************************** compute bounding spheres *****************************/
            
            // loopa genom alla vertexar i grupp
            // hitta tre par vertexar för varje dimension
            let minX=0, maxX=0, minY=0, maxY=0, minZ=0, maxZ=0, averagePos = new THREE.Vector3(0,0,0);
            for (let i = 0; i < indexArray.length; i++) {
                if(planeVertices.getX(minX) > planeVertices.getX(i))
                    minX = i;
                if(planeVertices.getX(maxX) < planeVertices.getX(i))
                    maxX = i;
                if(planeVertices.getY(minY) > planeVertices.getY(i))
                    minY = i;
                if(planeVertices.getY(maxY) < planeVertices.getY(i))
                    maxY = i;
                if(planeVertices.getZ(minZ) > planeVertices.getZ(i))
                    minZ = i;
                if(planeVertices.getZ(maxZ) < planeVertices.getZ(i))
                    maxZ = i;
                
                averagePos.add(new THREE.Vector3(planeVertices.getX(i),planeVertices.getY(i),planeVertices.getZ(i)));
                //console.log(averagePos);
            }
            // The three resulting coordinate pairs for each axis
            //console.log("X-coords: " + planeVertices.getX(minX) + ", " + planeVertices.getX(maxX));
            //console.log("Y-coords: " + planeVertices.getY(minY) + ", " + planeVertices.getY(maxY));
            //console.log("Z-coords: " + planeVertices.getZ(minZ) + ", " + planeVertices.getZ(maxZ));
            
            let xDist = planeVertices.getX(maxX) - planeVertices.getX(minX);
            let yDist = planeVertices.getY(maxY) - planeVertices.getY(minY);
            let zDist = planeVertices.getZ(maxZ) - planeVertices.getZ(minZ);
            let biggestDist = Math.max(xDist, yDist, zDist);
            //console.log("biggets distance in axis" + biggestDist);
            let radius = biggestDist/2;
            //averagePos = bounding spheres center
            averagePos.divideScalar(indexArray.length);
            //console.log(averagePos);
            
            // loop through again to find non-included vertices
            for (let j = 0; j < indexArray.length; j++) {
                let distPointToSphereSquared = (planeVertices.getX(j)-averagePos.x)*(planeVertices.getX(j)-averagePos.x) + 
                   (planeVertices.getY(j)-averagePos.y)*(planeVertices.getY(j)-averagePos.y) + 
                   (planeVertices.getZ(j)-averagePos.z)*(planeVertices.getZ(j)-averagePos.z);
                
                if(distPointToSphereSquared > radius*radius)
                {
                    let distPointToSphere = Math.sqrt(distPointToSphereSquared);
                    let avrgPosX = (radius*averagePos.x +(distPointToSphere-radius)*planeVertices.getX(j))/distPointToSphere,
                    avrgPosY = (radius*averagePos.y +(distPointToSphere-radius)*planeVertices.getY(j))/distPointToSphere,
                    avrgPosZ = (radius*averagePos.z +(distPointToSphere-radius)*planeVertices.getZ(j))/distPointToSphere;
                    
                    radius = (radius + distPointToSphere)/2;
                    averagePos.set(avrgPosX, avrgPosY, avrgPosZ);
                    //console.log("Updated radius to: " + radius);
                    //console.log("Updated sphere center to: (" + avrgPosX + " ," + avrgPosY + " ," + avrgPosZ + ")");
                }
            }
            /*
            // Checks if any vertex is not covered by bounding sphere after creation and adjustments
            for (let j = 0; j < indexArray.length; j++) {
                if((planeVertices.getX(j)-averagePos.x)*(planeVertices.getX(j)-averagePos.x) + 
                   (planeVertices.getY(j)-averagePos.y)*(planeVertices.getY(j)-averagePos.y) + 
                   (planeVertices.getZ(j)-averagePos.z)*(planeVertices.getZ(j)-averagePos.z) > radius*radius)
                {
                    console.log("found vertex " + j + " outside of bounding sphere!");
                }
            }*/
            /*******************************************************/
            
            
            let material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );
			let cube = new THREE.Mesh( planeGeometry, material );
			scene.add( cube );

			camera.position.z = 15;

			let animate = function () {
				requestAnimationFrame( animate );
                
                cube.rotation.x += 0.01;
                cube.rotation.y += 0.01;

				renderer.render( scene, camera );
			};

			animate();
            
            //get vertex in group/leaf
            //console.log(root.firstQuadrant.thirdQuadrant.vertices[0]);            
            
        </script>
    </body>
</html>