<html>
	<head>
		<title>Cloth simulation</title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
	</head>
	<body>
		<script src="js/three.js"></script>
        <script src="js/OrbitControls.js"></script>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.6/dat.gui.min.js"></script>
		<script>
            
            
            /**********      dat.gui menu       ***********/
            
            function object() {
                this.wireframe = false;
                this.normals = false;
                this.windForce = 10;
                this.springConstant = 25;
                this.dampingConstant = 0.17;
                this.sphereRadius = 8;
            };
            let obj = new object();
            let gui = new dat.GUI();
            let showWireframe = gui.add(obj, 'wireframe');
            //Toggle wireframe on material
            showWireframe.onChange(() => {
                material.needsUpdate = true;
                material.wireframe = obj.wireframe;
            });
            let showNormals = gui.add(obj, 'normals');
            showNormals.onChange(()=>{
                if(obj.normals)
                {
                    scene.add(helper);
                }
                else
                {
                    scene.remove(helper);
                }
            });
            let setWindForce = gui.add(obj, 'windForce', 0, 60); //only displayed as integer
            //doesn't get updated during runtime?
            let setSpringConst = gui.add(obj, 'springConstant', 0, 50);
            setSpringConst.onChange(()=>{
                springConstant = obj.springConstant;
                structuralSpringConstant = springConstant/structuralSpringLength; // N/m
                shearSpringConstant = springConstant/shearSpringLength; // N/m
                bendSpringConstant = springConstant/bendSpringLength; // N/m
                
            });
            let setDampingConst = gui.add(obj, 'dampingConstant', 0, 1);
            setDampingConst.onChange(()=>{
                dampingConstant = obj.dampingConstant;
                structuralDampingConstant = dampingConstant/structuralSpringLength; // N/m
                shearDampingConstant = dampingConstant/shearSpringLength; // N/m
                bendDampingConstant = dampingConstant/bendSpringLength; // N/m
            });
            let setRadius = gui.add(obj, 'sphereRadius', 0, 10);
            
            
            /***************      Three.js setup       ****************/
            
			const scene = new THREE.Scene();
            
			const renderer = new THREE.WebGLRenderer();
			renderer.setSize( window.innerWidth, window.innerHeight );
			document.body.appendChild( renderer.domElement );
            
            //Resize canvas when window is resized
            window.addEventListener( 'resize', onWindowResize, false );
            function onWindowResize()
            {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize( window.innerWidth, window.innerHeight );
            }
            
            let camera = new THREE.PerspectiveCamera( 75, window.innerWidth/window.innerHeight, 0.1, 1000 );
            let controls = new THREE.OrbitControls(camera, renderer.domElement);
            camera.position.z = 6;
            // limit orbitcontrols
            controls.minDistance = 1;
            controls.maxDistance = 40;
            controls.enablePan = false;
            controls.update();
            
            // Objects in scene
            const WIDTHSEGMENTS = 40;
            const HEIGHTSEGMENTS = 40;
            const CLOTHWIDTH = 15;
            const CLOTHHEIGHT = 15;
            let geometry = new THREE.PlaneBufferGeometry( CLOTHWIDTH, CLOTHHEIGHT, WIDTHSEGMENTS, HEIGHTSEGMENTS );
            geometry.rotateX(Math.PI/2);
            geometry.translate(0,10,0);
            
            let sphereCenter = new THREE.Vector3(0,0,0);
            
            //console.log(geometry.userData.velocity);
            /*
            let directionalLight = new THREE.DirectionalLight( 0xffffff, 0.5 );
            directionalLight.position.set( 0, 0, 10 );
            scene.add( directionalLight );
            let directionalLight2 = new THREE.DirectionalLight( 0xffffff, 1 );
            directionalLight2.position.set( 0, 0, -10 );
            scene.add( directionalLight2 );
            */
            let light = new THREE.PointLight( 0xffffff, 1, 100 );
            light.position.set( 0, 0, 20 );
            scene.add( light );
            let light2 = new THREE.PointLight( 0xffffff, 1, 100 );
            light2.position.set( 0, 0, -5 );
            scene.add( light2 );
            let material = new THREE.MeshLambertMaterial( {color: 0xffff00, side: THREE.DoubleSide, wireframe: false} );
            let plane = new THREE.Mesh( geometry, material );
            scene.add( plane );
            let helper = new THREE.VertexNormalsHelper( plane, 0.5, 0x0000ff, 1 );
            
            /*****************************     Simulation      ***********************************/
            let timestep = 1/120; // s/frame
            let time = 0;
            const gravity = 9.82*16; // m/s^2
            let springConstant = obj.springConstant;
            const mass = 0.3*(CLOTHWIDTH*CLOTHHEIGHT)/((WIDTHSEGMENTS+1)*(HEIGHTSEGMENTS+1)); // kg (300 gsm where 1 gsm = 1 g/m^2)
            const structuralSpringLength = CLOTHWIDTH/WIDTHSEGMENTS; // m
            const bendSpringLength = 2 * structuralSpringLength; // m
            const shearSpringLength = Math.sqrt(2 * Math.pow(structuralSpringLength, 2)); // m
            let structuralSpringConstant = springConstant/structuralSpringLength; // N/m
            let shearSpringConstant = springConstant/shearSpringLength; // N/m
            let bendSpringConstant = springConstant/bendSpringLength; // N/m
            let dampingConstant = obj.dampingConstant;
            let structuralDampingConstant = dampingConstant/structuralSpringLength; // N/m
            let shearDampingConstant = dampingConstant/shearSpringLength; // N/m
            let bendDampingConstant = dampingConstant/bendSpringLength; // N/m
            
            // Init attribute vectors
            let planeVertices = geometry.getAttribute('position');
            geometry.userData.prevPosition = [];
            geometry.userData.velocity = [];
            geometry.userData.prevVelocity = [];
            geometry.userData.acceleration = [];
            geometry.userData.prevAcceleration = [];
            for (let i = 0; i < planeVertices.count; i += 1) 
            {
                geometry.userData.prevPosition.push(new THREE.Vector3(planeVertices.getX(i),planeVertices.getY(i),planeVertices.getZ(i)));
                geometry.userData.velocity.push(new THREE.Vector3(0,0,0));
                geometry.userData.prevVelocity.push(new THREE.Vector3(0,0,0));
                geometry.userData.acceleration.push(new THREE.Vector3(0,-gravity,0));
                geometry.userData.prevAcceleration.push(new THREE.Vector3(0,0,0));
            }
            //test to see that the are not updated together
            //planeVertices.setXYZ(0,1,2,3);
            //console.log(planeVertices);
            //console.log(geometry.userData.prevPosition);
            //geometry.userData.velocity[0].set(1,2,3);
            //console.log(geometry.userData.velocity);
            //console.log(geometry.userData.prevVelocity);
            
            // Init temp vectors
            let springForce = new THREE.Vector3(0,0,0); // N
            let dampingForce = new THREE.Vector3(0,0,0); // N
            let posDiff = new THREE.Vector3(0,0,0); // m
            let posDiffCopy = new THREE.Vector3(0,0,0); // m
            
            
            //console.log(planeVertices);
            // Render-loop
			const animate = function () {
				requestAnimationFrame( animate );
                
                // Updating vertices position
                geometry.attributes.position.needsUpdate = true;
                for (let i = 0; i < planeVertices.count; i += 1) 
                {   
                    springForce.set(0,0,0);
                    posDiff.set(0,0,0);
                    posDiffCopy.set(0,0,0);
                    dampingForce.set(0,0,0);
                    
                    function calcSpringForce(vertIndex, posDiff, springLength, springConst, dampConst) {
                        posDiff.set(planeVertices.getX(i)-planeVertices.getX(vertIndex),
                                    planeVertices.getY(i)-planeVertices.getY(vertIndex),
                                    planeVertices.getZ(i)-planeVertices.getZ(vertIndex));
                        posDiffCopy.set(posDiff.x,posDiff.y,posDiff.z);
                        //console.log(planeVertices.getX(vertIndex)-planeVertices.getX(i));
                        
                        // F_spring = -k_s(l_0-l) = -springConstant*normalized(posDiff)*springLength
                        springForce.add(posDiffCopy.sub(posDiff.normalize().multiplyScalar(springLength)).multiplyScalar(-springConst));
                        //console.log(posDiffCopy);
                        //console.log(posDiff.normalize().multiplyScalar(springLength));
                        //console.log(springForce);
                        
                        // F_damp = k_d(v1-v2)
                        dampingForce.add(geometry.userData.velocity[i].sub(geometry.userData.velocity[vertIndex]).multiplyScalar(dampConst));
                        //console.log(dampingForce);
                    }
                    
                    if(!( i <= WIDTHSEGMENTS)) //Suspended corners
                    {
                        //Structural springs
                        if(i > WIDTHSEGMENTS) //if not first row
                        {
                            calcSpringForce(i-WIDTHSEGMENTS-1, posDiff, structuralSpringLength, structuralSpringConstant, structuralDampingConstant);
                        }
                        if(i < (WIDTHSEGMENTS+1)*HEIGHTSEGMENTS) //if not last row
                        {
                            calcSpringForce(i+WIDTHSEGMENTS+1, posDiff, structuralSpringLength, structuralSpringConstant, structuralDampingConstant);
                        }
                        if(i%(WIDTHSEGMENTS+1) !== 0) //if not first column
                        {
                            calcSpringForce(i-1, posDiff, structuralSpringLength, structuralSpringConstant, structuralDampingConstant);
                        }
                        if((i-WIDTHSEGMENTS)%(WIDTHSEGMENTS+1) !== 0) //if not last column
                        {
                            calcSpringForce(i+1, posDiff, structuralSpringLength, structuralSpringConstant, structuralDampingConstant);
                        }
                        
                        //Shear springs
                        if(i > WIDTHSEGMENTS && i%(WIDTHSEGMENTS+1) !== 0) //if not first row and not first column
                        {
                            calcSpringForce(i-WIDTHSEGMENTS-2, posDiff, shearSpringLength, shearSpringConstant, shearDampingConstant);
                        }
                        if(i > WIDTHSEGMENTS && (i-WIDTHSEGMENTS)%(WIDTHSEGMENTS+1) !== 0) //if not first row and not last column
                        {
                            calcSpringForce(i-WIDTHSEGMENTS, posDiff, shearSpringLength, shearSpringConstant, shearDampingConstant);
                        }
                        if(i < (WIDTHSEGMENTS+1)*HEIGHTSEGMENTS && i%(WIDTHSEGMENTS+1) !== 0) //if not last row and not first column
                        {
                            calcSpringForce(i+WIDTHSEGMENTS, posDiff, shearSpringLength, shearSpringConstant, shearDampingConstant);
                        }
                        if(i < (WIDTHSEGMENTS+1)*HEIGHTSEGMENTS && (i-WIDTHSEGMENTS)%(WIDTHSEGMENTS+1) !== 0) //if not last row and not last column
                        {
                            calcSpringForce(i+WIDTHSEGMENTS+2, posDiff, shearSpringLength, shearSpringConstant, shearDampingConstant);
                        }
                        
                        //Bending springs
                        if(i > 2*WIDTHSEGMENTS+1) //if not first or second row
                        {
                            calcSpringForce(i-2*(WIDTHSEGMENTS+1), posDiff, bendSpringLength, bendSpringConstant, bendDampingConstant);
                        }
                        if(i < (WIDTHSEGMENTS+1)*(HEIGHTSEGMENTS-1)) //if not second last or last row
                        {
                            calcSpringForce(i+2*(WIDTHSEGMENTS+1), posDiff, bendSpringLength, bendSpringConstant, bendDampingConstant);
                        }
                        if(i%(WIDTHSEGMENTS+1) !== 0 && (i-1)%(WIDTHSEGMENTS+1) !== 0) //if not first or second column
                        {
                            calcSpringForce(i-2, posDiff, bendSpringLength, bendSpringConstant, bendDampingConstant);
                        }
                        if((i-WIDTHSEGMENTS)%(WIDTHSEGMENTS+1) !== 0 && (i-WIDTHSEGMENTS+1)%(WIDTHSEGMENTS+1) !== 0) //if not second last or last column
                        {
                            calcSpringForce(i+2, posDiff, bendSpringLength, bendSpringConstant, bendDampingConstant);
                        }
                        
                        let prevPos = geometry.userData.prevPosition[i];
                        let prevVel = geometry.userData.prevVelocity[i];
                        let vel = geometry.userData.velocity[i];
                        let prevAcc = geometry.userData.prevAcceleration[i];
                        let acc = geometry.userData.acceleration[i];
                        
                        //Update previous position
                        prevPos.set(planeVertices.getX(i), planeVertices.getY(i), planeVertices.getZ(i)); //For xyz at the same time
                        prevVel = vel;
                        //console.log(geometry.userData.prevPosition[i]);
                        //console.log(geometry.userData.prevVelocity[i]);
                        let newPos = new THREE.Vector3(prevPos.getComponent(0)+prevVel.getComponent(0)*timestep+prevAcc.getComponent(0)*Math.pow(timestep,2)*0.5,
                                      prevPos.getComponent(1)+prevVel.getComponent(1)*timestep+prevAcc.getComponent(1)*Math.pow(timestep,2)*0.5,
                                      prevPos.getComponent(2)+prevVel.getComponent(2)*timestep+prevAcc.getComponent(2)*Math.pow(timestep,2)*0.5);
                        //let newPosX = prevPos.getComponent(0)+prevVel.getComponent(0)*timestep+prevAcc.getComponent(0)*Math.pow(timestep,2)*0.5;
                        //let newPosY = prevPos.getComponent(1)+prevVel.getComponent(1)*timestep+prevAcc.getComponent(1)*Math.pow(timestep,2)*0.5;
                        //let newPosZ = prevPos.getComponent(2)+prevVel.getComponent(2)*timestep+prevAcc.getComponent(2)*Math.pow(timestep,2)*0.5;
                        
                        //Project colliding vertices onto the spheres surface
                        if(newPos.distanceTo(sphereCenter) <= obj.sphereRadius) {
                            console.log("collision detected");
                            let collisionNormal = newPos.sub(sphereCenter).normalize().multiplyScalar(obj.sphereRadius).add(sphereCenter);
                            newPos.copy(collisionNormal);
                        }
                        planeVertices.setXYZ(i, newPos.getComponent(0), newPos.getComponent(1), newPos.getComponent(2));
                        // F_net = F_spring - F_damp - F_g + F_wind
                        acc.set((springForce.getComponent(0)-dampingForce.getComponent(0))/mass,
                                (-gravity*mass+springForce.getComponent(1)-dampingForce.getComponent(1))/mass,
                                (springForce.getComponent(2)-dampingForce.getComponent(2)+obj.windForce*Math.cos(time/450))/mass);
                        vel.set(prevVel.getComponent(0)+(prevAcc.getComponent(0)+acc.getComponent(0))*(timestep*0.5),
                                prevVel.getComponent(1)+(prevAcc.getComponent(1)+acc.getComponent(1))*(timestep*0.5),
                                prevVel.getComponent(2)+(prevAcc.getComponent(2)+acc.getComponent(2))*(timestep*0.5));
                        prevPos.set(planeVertices.getX(i),planeVertices.getY(i),planeVertices.getZ(i));
                        prevVel.set(vel.getComponent(0), vel.getComponent(1), vel.getComponent(2));
                        prevAcc.set(acc.getComponent(0), acc.getComponent(1), acc.getComponent(2));
                        
                        time += timestep;
                    }
                }
                
				//plane.rotation.x += 0.01;
				//plane.rotation.y += 0.01;
                
                //update normals for better shadows
                geometry.computeVertexNormals(false);
                geometry.normalizeNormals();
				helper.update();
                controls.update();
                renderer.render( scene, camera );
			};

			animate();
		</script>
	</body>
</html>