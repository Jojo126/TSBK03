<html>
	<head>
		<title>Cloth simulation</title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
	</head>
	<body>
		<script src="js/three.js"></script>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.6/dat.gui.min.js"></script>
		<script>
            
            
            /**********      dat.gui menu       ***********/
            
            function object() {
                this.wireframe = false;
                this.normals = false;
                this.windForce = 0;
                this.springConstant = 7;
                this.dampingConstant = 0.04;
            };
            let obj = new object();
            let gui = new dat.GUI();
            let showWireframe = gui.add(obj, 'wireframe');
            //Toggle wireframe on material
            showWireframe.onChange(() => {
                material.needsUpdate = true;
                material.wireframe = obj.wireframe;
            });
            let showNormals = gui.add(obj, 'normals');
            showNormals.onChange(()=>{
                if(obj.normals)
                {
                    scene.add(helper);
                }
                else
                {
                    scene.remove(helper);
                }
            });
            let setWindForce = gui.add(obj, 'windForce', 0, 10); //only displayed as integer
            //doesn't get updated during runtime?
            let setSpringConst = gui.add(obj, 'springConstant', 0, 10);
            setSpringConst.onChange(()=>{
                springConstant = obj.springConstant;
                structuralSpringConstant = springConstant/structuralSpringLength; // N/m
                shearSpringConstant = springConstant/shearSpringLength; // N/m
                bendSpringConstant = springConstant/bendSpringLength; // N/m
                
            });
            let setDampingConst = gui.add(obj, 'dampingConstant', 0, 0.05);
            setDampingConst.onChange(()=>{
                dampingConstant = obj.dampingConstant;
                structuralDampingConstant = dampingConstant/structuralSpringLength; // N/m
                shearDampingConstant = dampingConstant/shearSpringLength; // N/m
                bendDampingConstant = dampingConstant/bendSpringLength; // N/m
            });
            
            
            /***************      Three.js setup       ****************/
            
			const scene = new THREE.Scene();
			let camera = new THREE.PerspectiveCamera( 75, window.innerWidth/window.innerHeight, 0.1, 1000 );
            camera.position.z = 5;

			const renderer = new THREE.WebGLRenderer();
			renderer.setSize( window.innerWidth, window.innerHeight );
			document.body.appendChild( renderer.domElement );
            
            //Resize canvas when window is resized
            window.addEventListener( 'resize', onWindowResize, false );
            function onWindowResize()
            {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize( window.innerWidth, window.innerHeight );
            }
            
            // Objects in scene
            const WIDTHSEGMENTS = 15;
            const HEIGHTSEGMENTS = 15;
            const CLOTHWIDTH = 5;
            const CLOTHHEIGHT = 5;
            let geometry = new THREE.PlaneBufferGeometry( CLOTHWIDTH, CLOTHHEIGHT, WIDTHSEGMENTS, HEIGHTSEGMENTS );
            //console.log(geometry.userData.velocity);
            /*
            let directionalLight = new THREE.DirectionalLight( 0xffffff, 0.5 );
            directionalLight.position.set( 0, 0, 10 );
            scene.add( directionalLight );
            let directionalLight2 = new THREE.DirectionalLight( 0xffffff, 1 );
            directionalLight2.position.set( 0, 0, -10 );
            scene.add( directionalLight2 );
            */
            let light = new THREE.PointLight( 0xffffff, 1, 100 );
            light.position.set( 0, 0, 10 );
            scene.add( light );
            let material = new THREE.MeshLambertMaterial( {color: 0xffff00, side: THREE.DoubleSide, wireframe: false} );
            let plane = new THREE.Mesh( geometry, material );
            scene.add( plane );
            let helper = new THREE.VertexNormalsHelper( plane, 0.5, 0x0000ff, 1 );
            
            /*****************************     Simulation      ***********************************/
            let timestep = 1/50; // s/frame
            let time = 0;
            const gravity = 9.82; // m/s^2
            let springConstant = obj.springConstant;
            const mass = 0.3*(CLOTHWIDTH*CLOTHHEIGHT)/((WIDTHSEGMENTS+1)*(HEIGHTSEGMENTS+1)); // kg (300 gsm where 1 gsm = 1 g/m^2)
            const structuralSpringLength = CLOTHWIDTH/WIDTHSEGMENTS; // m
            const bendSpringLength = 2 * structuralSpringLength; // m
            const shearSpringLength = Math.sqrt(2 * Math.pow(structuralSpringLength, 2)); // m
            let structuralSpringConstant = springConstant/structuralSpringLength; // N/m
            let shearSpringConstant = springConstant/shearSpringLength; // N/m
            let bendSpringConstant = springConstant/bendSpringLength; // N/m
            let dampingConstant = obj.dampingConstant;
            let structuralDampingConstant = dampingConstant/structuralSpringLength; // N/m
            let shearDampingConstant = dampingConstant/shearSpringLength; // N/m
            let bendDampingConstant = dampingConstant/bendSpringLength; // N/m
            
            // Init attribute vectors
            let planeVertices = geometry.getAttribute('position');
            geometry.userData.prevPosition = [];
            geometry.userData.velocity = [];
            geometry.userData.prevVelocity = [];
            geometry.userData.acceleration = [];
            geometry.userData.prevAcceleration = [];
            for (let i = 0; i < planeVertices.count; i += 1) 
            {
                geometry.userData.prevPosition.push(new THREE.Vector3(planeVertices.getX(i),planeVertices.getY(i),planeVertices.getZ(i)));
                geometry.userData.velocity.push(new THREE.Vector3(0,0,0));
                geometry.userData.prevVelocity.push(new THREE.Vector3(0,0,0));
                geometry.userData.acceleration.push(new THREE.Vector3(0,-gravity,0));
                geometry.userData.prevAcceleration.push(new THREE.Vector3(0,0,0));
            }
            //test to see that the are not updated together
            //planeVertices.setXYZ(0,1,2,3);
            //console.log(planeVertices);
            //console.log(geometry.userData.prevPosition);
            //geometry.userData.velocity[0].set(1,2,3);
            //console.log(geometry.userData.velocity);
            //console.log(geometry.userData.prevVelocity);
            
            // Init temp vectors
            let springForce = new THREE.Vector3(0,0,0); // N
            let dampingForce = new THREE.Vector3(0,0,0); // N
            let posDiff = new THREE.Vector3(0,0,0); // m
            let posDiffCopy = new THREE.Vector3(0,0,0); // m
            
            
            //console.log(planeVertices);
            // Render-loop
			const animate = function () {
				requestAnimationFrame( animate );
                
                // Updating vertices position
                geometry.attributes.position.needsUpdate = true;
                for (let i = 0; i < planeVertices.count; i += 1) 
                {   
                    springForce.set(0,0,0);
                    posDiff.set(0,0,0);
                    posDiffCopy.set(0,0,0);
                    dampingForce.set(0,0,0);
                    
                    function calcSpringForce(vertIndex, posDiff, springLength, springConst, dampConst) {
                        posDiff.set(planeVertices.getX(i)-planeVertices.getX(vertIndex),
                                    planeVertices.getY(i)-planeVertices.getY(vertIndex),
                                    planeVertices.getZ(i)-planeVertices.getZ(vertIndex));
                        posDiffCopy.set(posDiff.x,posDiff.y,posDiff.z);
                        //console.log(planeVertices.getX(vertIndex)-planeVertices.getX(i));
                        
                        // F_spring = -k_s(l_0-l) = -springConstant*normalized(posDiff)*springLength
                        springForce.add(posDiffCopy.sub(posDiff.normalize().multiplyScalar(springLength)).multiplyScalar(-springConst));
                        //console.log(posDiffCopy);
                        //console.log(posDiff.normalize().multiplyScalar(springLength));
                        //console.log(springForce);
                        
                        // F_damp = k_d(v1-v2)
                        dampingForce.add(geometry.userData.velocity[i].sub(geometry.userData.velocity[vertIndex]).multiplyScalar(dampConst));
                        //console.log(dampingForce);
                    }
                    
                    if(!(i === 0 || i === WIDTHSEGMENTS)) //Suspended corners
                    {
                        //Structural springs
                        if(i > WIDTHSEGMENTS) //if not first row
                        {
                            calcSpringForce(i-WIDTHSEGMENTS-1, posDiff, structuralSpringLength, structuralSpringConstant, structuralDampingConstant);
                        }
                        if(i < (WIDTHSEGMENTS+1)*HEIGHTSEGMENTS) //if not last row
                        {
                            calcSpringForce(i+WIDTHSEGMENTS+1, posDiff, structuralSpringLength, structuralSpringConstant, structuralDampingConstant);
                        }
                        if(i%(WIDTHSEGMENTS+1) !== 0) //if not first column
                        {
                            calcSpringForce(i-1, posDiff, structuralSpringLength, structuralSpringConstant, structuralDampingConstant);
                        }
                        if((i-WIDTHSEGMENTS)%(WIDTHSEGMENTS+1) !== 0) //if not last column
                        {
                            calcSpringForce(i+1, posDiff, structuralSpringLength, structuralSpringConstant, structuralDampingConstant);
                        }
                        
                        //Shear springs
                        if(i > WIDTHSEGMENTS && i%(WIDTHSEGMENTS+1) !== 0) //if not first row and not first column
                        {
                            calcSpringForce(i-WIDTHSEGMENTS-2, posDiff, shearSpringLength, shearSpringConstant, shearDampingConstant);
                        }
                        if(i > WIDTHSEGMENTS && (i-WIDTHSEGMENTS)%(WIDTHSEGMENTS+1) !== 0) //if not first row and not last column
                        {
                            calcSpringForce(i-WIDTHSEGMENTS, posDiff, shearSpringLength, shearSpringConstant, shearDampingConstant);
                        }
                        if(i < (WIDTHSEGMENTS+1)*HEIGHTSEGMENTS && i%(WIDTHSEGMENTS+1) !== 0) //if not last row and not first column
                        {
                            calcSpringForce(i+WIDTHSEGMENTS, posDiff, shearSpringLength, shearSpringConstant, shearDampingConstant);
                        }
                        if(i < (WIDTHSEGMENTS+1)*HEIGHTSEGMENTS && (i-WIDTHSEGMENTS)%(WIDTHSEGMENTS+1) !== 0) //if not last row and not last column
                        {
                            calcSpringForce(i+WIDTHSEGMENTS+2, posDiff, shearSpringLength, shearSpringConstant, shearDampingConstant);
                        }
                        
                        //Bending springs
                        if(i > 2*WIDTHSEGMENTS+1) //if not first or second row
                        {
                            calcSpringForce(i-2*(WIDTHSEGMENTS+1), posDiff, bendSpringLength, bendSpringConstant, bendDampingConstant);
                        }
                        if(i < (WIDTHSEGMENTS+1)*(HEIGHTSEGMENTS-1)) //if not second last or last row
                        {
                            calcSpringForce(i+2*(WIDTHSEGMENTS+1), posDiff, bendSpringLength, bendSpringConstant, bendDampingConstant);
                        }
                        if(i%(WIDTHSEGMENTS+1) !== 0 && (i-1)%(WIDTHSEGMENTS+1) !== 0) //if not first or second column
                        {
                            calcSpringForce(i-2, posDiff, bendSpringLength, bendSpringConstant, bendDampingConstant);
                        }
                        if((i-WIDTHSEGMENTS)%(WIDTHSEGMENTS+1) !== 0 && (i-WIDTHSEGMENTS+1)%(WIDTHSEGMENTS+1) !== 0) //if not second last or last column
                        {
                            calcSpringForce(i+2, posDiff, bendSpringLength, bendSpringConstant, bendDampingConstant);
                        }
                        
                        //Update previous position
                        
                        geometry.userData.prevPosition[i].set(planeVertices.getX(i), planeVertices.getY(i), planeVertices.getZ(i)); //For xyz at the same time
                        geometry.userData.prevVelocity[i] = geometry.userData.velocity[i];
                        //console.log(geometry.userData.prevPosition[i]);
                        //console.log(geometry.userData.prevVelocity[i]);
                        
                        planeVertices.setXYZ(i,
                                             geometry.userData.prevPosition[i].getComponent(0)+geometry.userData.prevVelocity[i].getComponent(0)*timestep+geometry.userData.prevAcceleration[i].getComponent(0)*Math.pow(timestep,2)*0.5,
                                             geometry.userData.prevPosition[i].getComponent(1)+geometry.userData.prevVelocity[i].getComponent(1)*timestep+geometry.userData.prevAcceleration[i].getComponent(1)*Math.pow(timestep,2)*0.5,
                                             geometry.userData.prevPosition[i].getComponent(2)+geometry.userData.prevVelocity[i].getComponent(2)*timestep+geometry.userData.prevAcceleration[i].getComponent(2)*Math.pow(timestep,2)*0.5);
                        // F_net = F_spring - F_damp - F_g + F_wind
                        geometry.userData.acceleration[i].set((springForce.getComponent(0)-dampingForce.getComponent(0))/mass,
                                                              (-gravity*mass+springForce.getComponent(1)-dampingForce.getComponent(1))/mass,
                                                              (springForce.getComponent(2)-dampingForce.getComponent(2)+obj.windForce*Math.cos(time/450))/mass);
                        geometry.userData.velocity[i].set(geometry.userData.prevVelocity[i].getComponent(0)+(geometry.userData.prevAcceleration[i].getComponent(0)+geometry.userData.acceleration[i].getComponent(0))*(timestep*0.5),
                                                          geometry.userData.prevVelocity[i].getComponent(1)+(geometry.userData.prevAcceleration[i].getComponent(1)+geometry.userData.acceleration[i].getComponent(1))*(timestep*0.5),
                                                          geometry.userData.prevVelocity[i].getComponent(2)+(geometry.userData.prevAcceleration[i].getComponent(2)+geometry.userData.acceleration[i].getComponent(2))*(timestep*0.5));
                        geometry.userData.prevPosition[i].set(planeVertices.getX(i),planeVertices.getY(i),planeVertices.getZ(i));
                        geometry.userData.prevVelocity[i].set(geometry.userData.velocity[i].getComponent(0),
                                                              geometry.userData.velocity[i].getComponent(1),
                                                              geometry.userData.velocity[i].getComponent(2));
                        geometry.userData.prevAcceleration[i].set(geometry.userData.acceleration[i].getComponent(0),
                                                                  geometry.userData.acceleration[i].getComponent(1),
                                                                  geometry.userData.acceleration[i].getComponent(2));
                        
                        /*
                        let accX = (springForce.getComponent(0)+dampingForce.getComponent(0))/mass;
                        let accY = (gravity*mass+springForce.getComponent(1)+dampingForce.getComponent(1))/mass;
                        let accZ = (springForce.getComponent(2)+dampingForce.getComponent(2)+obj.windForce*Math.cos(time/450))/mass;
                        //console.log(dampingForce.getComponent(0)); // 0
                        //console.log("springforce: " + springForce.getComponent(0)); //nan
                        //console.log("accX: " + accX); // nan
                        
                        planeVertices.setXYZ(i, 
                                             2*planeVertices.getX(i) - geometry.userData.prevPosition[i].getComponent(0) - Math.pow(timestep,2)*accX,
                                             2*planeVertices.getY(i) - geometry.userData.prevPosition[i].getComponent(1) - Math.pow(timestep,2)*accY,
                                             2*planeVertices.getZ(i) - geometry.userData.prevPosition[i].getComponent(2) - Math.pow(timestep,2)*accZ);
                        
                        geometry.userData.velocity[i].setX(2*geometry.userData.velocity[i].getComponent(0) - geometry.userData.prevVelocity[i].getComponent(0)-timestep*accX);
                        geometry.userData.velocity[i].setY(2*geometry.userData.velocity[i].getComponent(1) - geometry.userData.prevVelocity[i].getComponent(1)-timestep*accY);
                        geometry.userData.velocity[i].setZ(2*geometry.userData.velocity[i].getComponent(2) - geometry.userData.prevVelocity[i].getComponent(2)-timestep*accZ);
                        */
                        time += timestep;
                    }
                }
                
				//plane.rotation.x += 0.01;
				//plane.rotation.y += 0.01;
                
                //update normals for better shadows
                geometry.computeVertexNormals(false);
                geometry.normalizeNormals();
				helper.update();
                renderer.render( scene, camera );
			};

			animate();
		</script>
	</body>
</html>