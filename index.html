<html>
	<head>
		<title>Cloth simulation</title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
	</head>
	<body>
		<script src="js/three.js"></script>
		<script>
            
			var scene = new THREE.Scene();
			var camera = new THREE.PerspectiveCamera( 75, window.innerWidth/window.innerHeight, 0.1, 1000 );
            camera.position.z = 5;

			var renderer = new THREE.WebGLRenderer();
			renderer.setSize( window.innerWidth, window.innerHeight );
			document.body.appendChild( renderer.domElement );
            
            // Objects in scene
            const WIDTHVERTICES = 7;
            const HEIGHTVERTICES = 9;
            var geometry = new THREE.PlaneBufferGeometry( 3, 3, WIDTHVERTICES, HEIGHTVERTICES );
            var planeVertices = geometry.getAttribute('position');
            geometry.userData.oldPosition = planeVertices;
            
            
            var material = new THREE.MeshBasicMaterial( {color: 0xffff00, side: THREE.DoubleSide, wireframe: true} );
            var plane = new THREE.Mesh( geometry, material );
            scene.add( plane );
            
			//console.log(geometry.userData.oldPosition.array);
            //console.log(planeVertices.array);
            
            const gravity = 9.8;
            const mass = 1;
            const springConstant = 300;
            let timestep = 1/30;
            let springForceY = 0;
            
            
            // Render-loop
			var animate = function () {
				requestAnimationFrame( animate );
                
                // Updating vertices position
                geometry.attributes.position.needsUpdate = true;
                for (let i = 0; i < planeVertices.count; i += 1) {
                    
                    if(!(i === 0 || i === WIDTHVERTICES)) //Suspended corners
                    {
                        if( i > WIDTHVERTICES && i < (WIDTHVERTICES+1)*HEIGHTVERTICES)
                        {
                            
                            springForceY = springConstant*(planeVertices.getY(i-WIDTHVERTICES-1)-planeVertices.getY(i)+planeVertices.getY(i+WIDTHVERTICES+1)-planeVertices.getY(i));
                            
                        }
                        let newPosY = 2*planeVertices.getY(i) - geometry.userData.oldPosition.getY(i) - Math.pow(timestep,2)*(gravity-springForceY)/mass;
                        planeVertices.setY(i, newPosY);
                        //geometry.userData.oldPosition.array = planeVertices.array;
                        
                        geometry.userData.oldPosition.setY(i, planeVertices.getY(i));
                        
                        //console.log('oldPos: ' + geometry.userData.oldPosition.array);
                        //console.log('newPos: ' + planeVertices.array);
                    }
                }
                
				//plane.rotation.x += 0.01;
				//plane.rotation.y += 0.01;

				renderer.render( scene, camera );
			};

			animate();
		</script>
	</body>
</html>