<html>
	<head>
		<title>Cloth simulation</title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
	</head>
	<body>
		<script src="js/three.js"></script>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.6/dat.gui.min.js"></script>
		<script>
            function object() {
                this.wireframe = false;
                this.windForce = 0;
            };
            let obj = new object();
            let gui = new dat.GUI();
            let showWireframe = gui.add(obj, 'wireframe');
            //Toggle wireframe on material
            showWireframe.onChange(() => {
                material.needsUpdate = true;
                material.wireframe = obj.wireframe;
            });
            let setWindForce = gui.add(obj, 'windForce', 0, 10); //only displayed as integer
            
			const scene = new THREE.Scene();
			let camera = new THREE.PerspectiveCamera( 75, window.innerWidth/window.innerHeight, 0.1, 1000 );
            camera.position.z = 5;

			const renderer = new THREE.WebGLRenderer();
			renderer.setSize( window.innerWidth, window.innerHeight );
			document.body.appendChild( renderer.domElement );
            
            // Objects in scene
            const WIDTHSEGMENTS = 5;
            const HEIGHTSEGMENTS = 5;
            const CLOTHWIDTH = 5;
            const CLOTHHEIGHT = 5;
            let geometry = new THREE.PlaneBufferGeometry( CLOTHWIDTH, CLOTHHEIGHT, WIDTHSEGMENTS, HEIGHTSEGMENTS );
            let planeVertices = geometry.getAttribute('position');
            geometry.userData.oldPosition = planeVertices;
            /*
            let directionalLight = new THREE.DirectionalLight( 0xffffff, 0.5 );
            directionalLight.position.set( 0, 0, 10 );
            scene.add( directionalLight );
            let directionalLight2 = new THREE.DirectionalLight( 0xffffff, 1 );
            directionalLight2.position.set( 0, 0, -10 );
            scene.add( directionalLight2 );
            */
            let light = new THREE.PointLight( 0xffffff, 1, 100 );
            light.position.set( 0, 0, 10 );
            scene.add( light );
            let material = new THREE.MeshLambertMaterial( {color: 0xffff00, side: THREE.DoubleSide, wireframe: false} );
            let plane = new THREE.Mesh( geometry, material );
            scene.add( plane );
            
            const gravity = 9.8; // m/s^2
            const structuralSpringLength = CLOTHWIDTH/WIDTHSEGMENTS; // m
            const bendSpringLength = 2 * structuralSpringLength; // m
            const shearSpringLength = Math.sqrt(2 * Math.pow(structuralSpringLength, 2)); // m
            const structuralSpringConstant = 25/structuralSpringLength; // N/m
            const shearSpringConstant = 25/shearSpringLength; // N/m
            const bendSpringConstant = 25/bendSpringLength; // N/m
            const mass = 0.3*Math.pow(structuralSpringLength,2)/4; // kg  (300 gsm where 1000 gsm = 1 kg/m^2, typically 4 vertices per m^2)
            let timestep = 1/30; // s/frame
            let springForce = new THREE.Vector3(0,0,0); // N
            let tempVec = new THREE.Vector3(0,0,0); // m
            let tempVec2 = new THREE.Vector3(0,0,0); // m
            let time = 0;
            
            // Render-loop
			const animate = function () {
				requestAnimationFrame( animate );
                
                // Updating vertices position
                geometry.attributes.position.needsUpdate = true;
                for (let i = 0; i < planeVertices.count; i += 1) 
                {    
                    springForce.set(0,0,0);
                    tempVec.set(0,0,0);
                    tempVec2.set(0,0,0);
                    
                    function calcSpringForce(vertIndex, tempVec, springLength, springConstant) {
                        tempVec.set(planeVertices.getX(vertIndex)-planeVertices.getX(i),
                                    planeVertices.getY(vertIndex)-planeVertices.getY(i),
                                    planeVertices.getZ(vertIndex)-planeVertices.getZ(i));
                        tempVec2.set(tempVec.x,tempVec.y,tempVec.z);
                        springForce.add(tempVec2.sub(tempVec.normalize().multiplyScalar(springLength)).multiplyScalar(-springConstant));
                    }
                    
                    if(!(i === 0 || i === WIDTHSEGMENTS)) //Suspended corners
                    {
                        //Structural springs
                        if(i > WIDTHSEGMENTS) //if not first row
                        {
                            calcSpringForce(i-WIDTHSEGMENTS-1, tempVec, structuralSpringLength, structuralSpringConstant);
                        }
                        if(i < (WIDTHSEGMENTS+1)*HEIGHTSEGMENTS) //if not last row
                        {
                            calcSpringForce(i+WIDTHSEGMENTS+1, tempVec, structuralSpringLength, structuralSpringConstant);
                        }
                        if(i%(WIDTHSEGMENTS+1) !== 0) //if not first column
                        {
                            calcSpringForce(i-1, tempVec, structuralSpringLength, structuralSpringConstant);
                        }
                        if((i-WIDTHSEGMENTS)%(WIDTHSEGMENTS+1) !== 0) //if not last column
                        {
                            calcSpringForce(i+1, tempVec, structuralSpringLength, structuralSpringConstant);
                        }
                        
                        //Shear springs
                        if(i > WIDTHSEGMENTS && i%(WIDTHSEGMENTS+1) !== 0) //if not first row and not first column
                        {
                            calcSpringForce(i-WIDTHSEGMENTS-2, tempVec, shearSpringLength, shearSpringConstant);
                        }
                        if(i > WIDTHSEGMENTS && (i-WIDTHSEGMENTS)%(WIDTHSEGMENTS+1) !== 0) //if not first row and not last column
                        {
                            calcSpringForce(i-WIDTHSEGMENTS, tempVec, shearSpringLength, shearSpringConstant);
                        }
                        if(i < (WIDTHSEGMENTS+1)*HEIGHTSEGMENTS && i%(WIDTHSEGMENTS+1) !== 0) //if not last row and not first column
                        {
                            calcSpringForce(i+WIDTHSEGMENTS, tempVec, shearSpringLength, shearSpringConstant);
                        }
                        if(i < (WIDTHSEGMENTS+1)*HEIGHTSEGMENTS && (i-WIDTHSEGMENTS)%(WIDTHSEGMENTS+1) !== 0) //if not last row and not last column
                        {
                            calcSpringForce(i+WIDTHSEGMENTS+2, tempVec, shearSpringLength, shearSpringConstant);
                        }
                        
                        //Bending springs
                        if(i > 2*WIDTHSEGMENTS+1) //if not first or second row
                        {
                            calcSpringForce(i-2*(WIDTHSEGMENTS+1), tempVec, bendSpringLength, bendSpringConstant);
                        }
                        if(i < (WIDTHSEGMENTS+1)*(HEIGHTSEGMENTS-1)) //if not second last or last row
                        {
                            calcSpringForce(i+2*(WIDTHSEGMENTS+1), tempVec, bendSpringLength, bendSpringConstant);
                        }
                        if(i%(WIDTHSEGMENTS+1) !== 0 && (i-1)%(WIDTHSEGMENTS+1) !== 0) //if not first or second column
                        {
                            calcSpringForce(i-2, tempVec, bendSpringLength, bendSpringConstant);
                        }
                        if((i-WIDTHSEGMENTS)%(WIDTHSEGMENTS+1) !== 0 && (i-WIDTHSEGMENTS+1)%(WIDTHSEGMENTS+1) !== 0) //if not second last or last column
                        {
                            calcSpringForce(i+2, tempVec, bendSpringLength, bendSpringConstant);
                        }
                        
                        
                        //Update old position
                        geometry.userData.oldPosition.setXYZ(planeVertices.getX(), planeVertices.getY(), planeVertices.getZ()); //For xyz at the same time
                        planeVertices.setXYZ(i, 
                                             2*planeVertices.getX(i) - geometry.userData.oldPosition.getX(i) - Math.pow(timestep,2)*(springForce.getComponent(0))/mass,
                                             2*planeVertices.getY(i) - geometry.userData.oldPosition.getY(i) - Math.pow(timestep,2)*(gravity*mass+springForce.getComponent(1))/mass,
                                             2*planeVertices.getZ(i) - geometry.userData.oldPosition.getZ(i) - Math.pow(timestep,2)*(springForce.getComponent(2)+obj.windForce*Math.cos(time/450))/mass);
                        time += timestep;
                    }
                }
                
				//plane.rotation.x += 0.01;
				//plane.rotation.y += 0.01;

				renderer.render( scene, camera );
			};

			animate();
		</script>
	</body>
</html>