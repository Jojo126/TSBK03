<html>
	<head>
		<title>Cloth simulation</title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
	</head>
	<body>
		<script src="js/three.js"></script>
		<script>
            
			const scene = new THREE.Scene();
			let camera = new THREE.PerspectiveCamera( 75, window.innerWidth/window.innerHeight, 0.1, 1000 );
            camera.position.z = 5;

			const renderer = new THREE.WebGLRenderer();
			renderer.setSize( window.innerWidth, window.innerHeight );
			document.body.appendChild( renderer.domElement );
            
            // Objects in scene
            const WIDTHVERTICES = 30;
            const HEIGHTVERTICES = 30;
            const CLOTHWIDTH = 5;
            const CLOTHHEIGHT = 5;
            let geometry = new THREE.PlaneBufferGeometry( CLOTHWIDTH, CLOTHHEIGHT, WIDTHVERTICES, HEIGHTVERTICES );
            let planeVertices = geometry.getAttribute('position');
            geometry.userData.oldPosition = planeVertices;
            
            
            let material = new THREE.MeshBasicMaterial( {color: 0xffff00, side: THREE.DoubleSide, wireframe: true} );
            let plane = new THREE.Mesh( geometry, material );
            scene.add( plane );
            
            const gravity = 9.8; // m/s^2
            const mass = 0.001; // kg
            const structuralSpringConstant = 1; // N/m
            const shearSpringConstant = 1; // N/m
            const bendSpringConstant = 1; // N/m
            const structuralSpringLength = CLOTHWIDTH/(WIDTHVERTICES); // m
            const bendSpringLength = 2 * structuralSpringLength; // m
            const shearSpringLength = Math.sqrt(2*Math.pow(structuralSpringLength,2)); // m
            let timestep = 1/60; // s/frame
            let springForce = new THREE.Vector3(0,0,0); // N
            let tempVec = new THREE.Vector3(0,0,0); // m
            let tempVec2 = new THREE.Vector3(0,0,0); // m
            let time = 0;
            
            // Render-loop
			const animate = function () {
				requestAnimationFrame( animate );
                
                // Updating vertices position
                geometry.attributes.position.needsUpdate = true;
                for (let i = 0; i < planeVertices.count; i += 1) 
                {    
                    springForce.set(0,0,0);
                    tempVec.set(0,0,0);
                    tempVec2.set(0,0,0);
                    
                    function calcSpringForce(vertIndex, tempVec, springLength, springConstant) {
                        tempVec.set(planeVertices.getX(vertIndex)-planeVertices.getX(i),
                                    planeVertices.getY(vertIndex)-planeVertices.getY(i),
                                    planeVertices.getZ(vertIndex)-planeVertices.getZ(i));
                        tempVec2.set(tempVec.x,tempVec.y,tempVec.z);
                        springForce.add(tempVec2.sub(tempVec.normalize().multiplyScalar(springLength)).multiplyScalar(-springConstant));
                    }
                    
                    if(!(i === 0 || i === WIDTHVERTICES)) //Suspended corners
                    {
                        //Structural springs
                        if(i > WIDTHVERTICES) //if not first row
                        {
                            calcSpringForce(i-WIDTHVERTICES-1, tempVec, structuralSpringLength, structuralSpringConstant);
                        }
                        if(i < (WIDTHVERTICES+1)*HEIGHTVERTICES) //if not last row
                        {
                            calcSpringForce(i+WIDTHVERTICES+1, tempVec, structuralSpringLength, structuralSpringConstant);
                        }
                        if(i%(WIDTHVERTICES+1) !== 0) //if not first column
                        {
                            calcSpringForce(i-1, tempVec, structuralSpringLength, structuralSpringConstant);
                        }
                        if((i-WIDTHVERTICES)%(WIDTHVERTICES+1) !== 0) //if not last column
                        {
                            calcSpringForce(i+1, tempVec, structuralSpringLength, structuralSpringConstant);
                        }
                        
                        //Shear springs
                        if(i > WIDTHVERTICES && i%(WIDTHVERTICES+1) !== 0) //if not first row and not first column
                        {
                            calcSpringForce(i-WIDTHVERTICES-2, tempVec, shearSpringLength, shearSpringConstant);
                        }
                        if(i > WIDTHVERTICES && (i-WIDTHVERTICES)%(WIDTHVERTICES+1) !== 0) //if not first row and not last column
                        {
                            calcSpringForce(i-WIDTHVERTICES, tempVec, shearSpringLength, shearSpringConstant);
                        }
                        if(i < (WIDTHVERTICES+1)*HEIGHTVERTICES && i%(WIDTHVERTICES+1) !== 0) //if not last row and not first column
                        {
                            calcSpringForce(i+WIDTHVERTICES, tempVec, shearSpringLength, shearSpringConstant);
                        }
                        if(i < (WIDTHVERTICES+1)*HEIGHTVERTICES && (i-WIDTHVERTICES)%(WIDTHVERTICES+1) !== 0) //if not last row and not last column
                        {
                            calcSpringForce(i+WIDTHVERTICES+2, tempVec, shearSpringLength, shearSpringConstant);
                        }
                        
                        //Bending springs
                        if(i > 2*WIDTHVERTICES+1) //if not first or second row
                        {
                            calcSpringForce(i-2*(WIDTHVERTICES+1), tempVec, bendSpringLength, bendSpringConstant);
                        }
                        if(i < (WIDTHVERTICES+1)*(HEIGHTVERTICES-1)) //if not second last or last row
                        {
                            calcSpringForce(i+2*(WIDTHVERTICES+1), tempVec, bendSpringLength, bendSpringConstant);
                        }
                        if(i%(WIDTHVERTICES+1) !== 0 && (i-1)%(WIDTHVERTICES+1) !== 0) //if not first or second column
                        {
                            calcSpringForce(i-2, tempVec, bendSpringLength, bendSpringConstant);
                        }
                        if((i-WIDTHVERTICES)%(WIDTHVERTICES+1) !== 0 && (i-WIDTHVERTICES+1)%(WIDTHVERTICES+1) !== 0) //if not second last or last column
                        {
                            calcSpringForce(i+2, tempVec, bendSpringLength, bendSpringConstant);
                        }
                        
                        
                        //Update old position
                        geometry.userData.oldPosition.setXYZ(planeVertices.getX(), planeVertices.getY(), planeVertices.getZ()); //For xyz at the same time
                        planeVertices.setXYZ(i, 
                                             2*planeVertices.getX(i) - geometry.userData.oldPosition.getX(i) - Math.pow(timestep,2)*(springForce.getComponent(0))/mass,
                                             2*planeVertices.getY(i) - geometry.userData.oldPosition.getY(i) - Math.pow(timestep,2)*(gravity*mass+springForce.getComponent(1))/mass,
                                             2*planeVertices.getZ(i) - geometry.userData.oldPosition.getZ(i) - Math.pow(timestep,2)*(springForce.getComponent(2)+0.1*Math.sin(time/500))/mass);
                        time += timestep;
                    }
                }
                
				//plane.rotation.x += 0.01;
				//plane.rotation.y += 0.01;

				renderer.render( scene, camera );
			};

			animate();
		</script>
	</body>
</html>